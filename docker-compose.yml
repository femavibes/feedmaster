# backend/docker-compose.yml
#
# This file defines the services for your Feedmaster backend application
# using Docker Compose. It orchestrates:
#   1. A PostgreSQL database service.
#   2. Your FastAPI API service.
#   3. A separate aggregator worker service.

version: '3.8' # Specify the Docker Compose file format version

services:
  db:
    image: postgres:15-alpine # Use a lightweight PostgreSQL image
    restart: always # Always restart the database service if it fails
    environment:
      POSTGRES_DB: feedmaster_db # Database name
      POSTGRES_USER: user # Database user
      POSTGRES_PASSWORD: password # Database password (CHANGE IN PRODUCTION!)
    volumes:
      - pgdata:/var/lib/postgresql/data # Persist database data to a named volume
    ports:
      - "5432:5432" # Map host port 5432 to container port 5432

  api:
    build:
      context: . # Build from the current directory (where Dockerfile is located)
      dockerfile: Dockerfile # Specify the Dockerfile to use
    command: uvicorn backend.main:app --host 0.0.0.0 --port 8000 --reload # Run FastAPI with Uvicorn in development mode
    volumes:
      - ./backend:/app/backend # Mount the backend code into /app/backend to preserve package structure
      - ./config:/app/config # Mount the config directory
    ports:
      - "8000:8000" # Map host port 8000 to container port 8000
    environment:
      # Load environment variables from the .env file.
      # Docker Compose automatically loads .env in the same directory as docker-compose.yml.
      # SECRET_KEY and other sensitive vars should be defined in your .env file.
      SECRET_KEY: ${SECRET_KEY} # Load from .env
      ALGORITHM: ${ALGORITHM} # Load from .env
      ACCESS_TOKEN_EXPIRE_MINUTES: ${ACCESS_TOKEN_EXPIRE_MINUTES} # Load from .env
      SQLALCHEMY_DATABASE_URL: ${SQLALCHEMY_DATABASE_URL} # Load from .env
      BLUESKY_API_BASE_URL: ${BLUESKY_API_BASE_URL} # Load from .env
      CONFIG_DIR: /app/config # Explicitly define CONFIG_DIR inside container
    depends_on:
      - db # Ensure the database service starts before the API service

  aggregator_worker:
    build:
      context: . # Build from the current directory
      dockerfile: Dockerfile # Use the same Dockerfile as the API
    command: python backend/aggregator_worker.py # Command to run the aggregator worker script
    volumes:
      - ./backend:/app/backend # Mount the backend code into /app/backend
      - ./config:/app/config # Mount the config directory
    environment:
      SECRET_KEY: ${SECRET_KEY} # Load from .env
      ALGORITHM: ${ALGORITHM} # Load from .env
      ACCESS_TOKEN_EXPIRE_MINUTES: ${ACCESS_TOKEN_EXPIRE_MINUTES} # Load from .env
      SQLALCHEMY_DATABASE_URL: ${SQLALCHEMY_DATABASE_URL} # Load from .env
      BLUESKY_API_BASE_URL: ${BLUESKY_API_BASE_URL} # Load from .env
      CONFIG_DIR: /app/config # Explicitly define CONFIG_DIR inside container
      WORKER_POLLING_INTERVAL_SECONDS: ${WORKER_POLLING_INTERVAL_SECONDS} # Load from .env
      AGGREGATION_INTERVAL_MINUTES: ${AGGREGATION_INTERVAL_MINUTES} # Load from .env
      PROMINENT_DID_REFRESH_INTERVAL_MINUTES: ${PROMINENT_DID_REFRESH_INTERVAL_MINUTES} # Load from .env
    depends_on:
      - db # Ensure the database is ready before the worker starts

volumes:
  pgdata: # Define the named volume for PostgreSQL data persistence
